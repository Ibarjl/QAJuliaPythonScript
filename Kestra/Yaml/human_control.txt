# =============================================================================
# FLUJO PRINCIPAL CON ERROR HANDLING Y PAUSE
# =============================================================================
id: monitoring_flow_with_error_handling
namespace: dev.monitoring
description: "Flujo con manejo de errores y pausa para intervenci√≥n humana"

variables:
  file_name: "monitoring_container_{{execution.id}}"
  org_usr: "ubuntu"
  org_ip: "172.26.6.5"
  org_password: "FT01.ITB01.cc1"

tasks:
  # =============================================================================
  # CONFIGURACI√ìN INICIAL
  # =============================================================================
  - id: setup_monitoring
    type: io.kestra.plugin.scripts.shell.Commands
    description: "Configurar contenedor de monitoreo"
    commands:
      - echo "üöÄ Iniciando configuraci√≥n de monitoreo..."
      - echo Contenedor: {{vars.file_name}}
      - |
        # Configurar contenedor Loki
        docker run -d \
          --name {{vars.file_name}} \
          --restart unless-stopped \
          -p 3100:3100 \
          grafana/loki:latest \
          -config.file=/etc/loki/local-config.yaml
        
        # Verificar que el contenedor est√© corriendo
        sleep 5
        if ! docker ps | grep -q {{vars.file_name}}; then
          echo "‚ùå ERROR: Contenedor no se inici√≥ correctamente"
          exit 1
        fi
        
        echo "‚úÖ Contenedor iniciado exitosamente"
        echo "üìä Iniciando tageo de Loki..."
        
        # Simular tageo de Loki (ajustar seg√∫n tu implementaci√≥n)
        docker exec {{vars.file_name}} /bin/sh -c "
          echo 'level=info msg=\"Monitoring started for {{vars.file_name}}\"' >> /var/log/loki.log
        "
    
    # Error handling para setup
    errors:
      - id: setup_error_handler
        type: io.kestra.core.tasks.flows.Sequential
        tasks:
          - id: log_setup_error
            type: io.kestra.plugin.scripts.shell.Commands
            commands:
              - echo "‚ùå ERROR EN CONFIGURACI√ìN INICIAL"
              - echo Detalles: {{ task.id }} fall√≥ durante setup
              - echo "Timestamp: $(date)"
              - echo Contenedor objetivo: {{vars.file_name}}
              
          - id: pause_on_setup_error
            type: io.kestra.core.tasks.flows.Pause
            description: "‚ö†Ô∏è ERROR EN SETUP - ¬øContinuar con el flujo o hacer Kill?"
            
          - id: confirm_continue_after_setup_error
            type: io.kestra.core.tasks.flows.Pause
            description: "‚ùì ¬øConfirmas que quieres CONTINUAR despu√©s del error de setup?"

  # =============================================================================
  # MONITOREO CONTINUO
  # =============================================================================
  - id: continuous_monitoring
    type: io.kestra.plugin.scripts.shell.Commands
    description: "Monitoreo continuo con verificaciones peri√≥dicas"
    commands:
      - echo "üîç Iniciando monitoreo continuo..."
      - |
        # Loop de monitoreo con verificaciones
        MONITOR_COUNT=0
        MAX_ERRORS=3
        ERROR_COUNT=0
        
        while true; do
          MONITOR_COUNT=$((MONITOR_COUNT + 1))
          echo "üîÑ Ciclo de monitoreo #$MONITOR_COUNT"
          
          # Verificar estado del contenedor
          if ! docker ps | grep -q {{vars.file_name}}; then
            echo "‚ùå ERROR: Contenedor {{vars.file_name}} no est√° corriendo"
            ERROR_COUNT=$((ERROR_COUNT + 1))
            
            if [ $ERROR_COUNT -ge $MAX_ERRORS ]; then
              echo "üí• M√ÅXIMO DE ERRORES ALCANZADO: $ERROR_COUNT/$MAX_ERRORS"
              exit 1
            fi
            
            echo "‚ö†Ô∏è Intento $ERROR_COUNT/$MAX_ERRORS - Continuando..."
            sleep 10
            continue
          fi
          
          # Verificar logs de Loki
          if ! docker exec {{vars.file_name}} ls /var/log/loki.log >/dev/null 2>&1; then
            echo "‚ö†Ô∏è WARNING: Archivo de log no encontrado"
            ERROR_COUNT=$((ERROR_COUNT + 1))
            
            if [ $ERROR_COUNT -ge $MAX_ERRORS ]; then
              echo "üí• M√öLTIPLES WARNINGS CONVERTIDOS EN ERROR"
              exit 1
            fi
          fi
          
          # Tagging de Loki
          docker exec {{vars.file_name}} /bin/sh -c "
            echo 'level=info msg=\"Monitoring cycle $MONITOR_COUNT completed\"' >> /var/log/loki.log
          "
          
          # Simular posible error aleatorio (remover en producci√≥n)
          if [ $((MONITOR_COUNT % 10)) -eq 0 ]; then
            echo "üé≤ Simulando posible error en ciclo $MONITOR_COUNT..."
            if [ $((RANDOM % 100)) -lt 20 ]; then
              echo "üí• ERROR SIMULADO: Fallo en verificaci√≥n de conectividad"
              exit 1
            fi
          fi
          
          echo "‚úÖ Ciclo $MONITOR_COUNT completado exitosamente"
          sleep 30  # Intervalo de monitoreo
        done
    
    # Error handling para monitoreo
    errors:
      - id: monitoring_error_handler
        type: io.kestra.core.tasks.flows.Sequential
        tasks:
          - id: log_monitoring_error
            type: io.kestra.plugin.scripts.shell.Commands
            commands:
              - echo "‚ùå ERROR EN MONITOREO CONTINUO"
              - echo "Detalles: {{task.id}} fall√≥ durante monitoreo"
              - echo "Timestamp: $(date)"
              - echo Contenedor: {{vars.file_name}}
              - |
                # Capturar logs del contenedor para debugging
                echo "üìã LOGS DEL CONTENEDOR:"
                docker logs {{vars.file_name}} --tail 20 || echo "No se pudieron obtener logs"
                
                echo "üîç ESTADO DEL CONTENEDOR:"
                docker ps -a | grep {{vars.file_name}} || echo "Contenedor no encontrado"
                
          - id: pause_on_monitoring_error
            type: io.kestra.core.tasks.flows.Pause
            description: "‚ö†Ô∏è ERROR EN MONITOREO - ¬øContinuar con el flujo o hacer Kill?"
            
          - id: confirm_continue_after_monitoring_error
            type: io.kestra.core.tasks.flows.Pause
            description: "‚ùì ¬øConfirmas que quieres CONTINUAR despu√©s del error de monitoreo?"

  # =============================================================================
  # CONFIRMACI√ìN ANTES DE PAUSA NORMAL
  # =============================================================================
  - id: confirm_proceed_to_pause
    type: io.kestra.core.tasks.flows.Pause
    description: "‚ùì Sistema funcionando correctamente. ¬øContinuar a la pausa para intervenci√≥n humana?"

  # =============================================================================
  # PAUSA NORMAL PARA INTERVENCI√ìN HUMANA
  # =============================================================================
  - id: pause_for_human_intervention
    type: io.kestra.core.tasks.flows.Pause
    description: "‚úã PAUSA NORMAL - Sistema funcionando, esperando intervenci√≥n humana"

  # =============================================================================
  # CONFIRMACI√ìN DESPU√âS DE PAUSA NORMAL
  # =============================================================================
  - id: confirm_continue_after_pause
    type: io.kestra.core.tasks.flows.Pause
    description: "‚ùì ¬øConfirmas que quieres CONTINUAR con las tareas post-pausa?"

  # =============================================================================
  # CONTINUACI√ìN POST-PAUSA
  # =============================================================================
  - id: post_pause_continuation
    type: io.kestra.plugin.scripts.shell.Commands
    description: "Tareas despu√©s de la pausa normal"
    commands:
      - echo "üéØ Continuando despu√©s de pausa normal..."
      - echo "Preparando para dumps de m√©tricas..."
      - |
        # Verificar estado antes de continuar
        if ! docker ps | grep -q {{vars.file_name}}; then
          echo "‚ùå ERROR: Contenedor ya no est√° disponible"
          exit 1
        fi
        
        echo "‚úÖ Sistema listo para dumps"

# =============================================================================
# FLOW PARA CONTINUACI√ìN CON PAR√ÅMETROS
# =============================================================================
---
id: dump_execution_flow
namespace: dev.monitoring
description: "Ejecutar dumps despu√©s de pausa o error"

inputs:
  - id: confirm_execution
    type: BOOLEAN
    defaults: false
    description: "‚ùì ¬øConfirmas que quieres ejecutar este dump?"
    
  - id: dump_type
    type: SELECT
    values: ["loki", "prometheus", "both"]
    defaults: "both"
    description: "Tipo de dump a ejecutar"
    
  - id: source_execution_id
    type: STRING
    description: "ID de la ejecuci√≥n original (opcional)"
    
  - id: error_recovery
    type: BOOLEAN
    defaults: false
    description: "¬øEs una recuperaci√≥n de error?"

tasks:
  - id: validate_confirmation
    type: io.kestra.plugin.scripts.shell.Commands
    description: "Validar confirmaci√≥n del usuario"
    commands:
      - |
        if [ "{{inputs.confirm_execution}}" != "true" ]; then
          echo "‚ùå EJECUCI√ìN CANCELADA - Confirmaci√≥n no recibida"
          echo "Para ejecutar este flow, marca 'confirm_execution' como true"
          exit 1
        fi
        
        echo "‚úÖ Confirmaci√≥n recibida - Procediendo con la ejecuci√≥n"
        echo "Tipo de dump: {{inputs.dump_type}}"
        echo "Recuperaci√≥n de error: {{inputs.error_recovery}}"

  - id: pre_dump_checks
    type: io.kestra.plugin.scripts.shell.Commands
    description: "Verificaciones antes del dump"
    commands:
      - echo "üîç Verificando estado del sistema..."
      - echo Tipo de dump: {{inputs.dump_type}}
      - echo Recuperaci√≥n de error: {{inputs.error_recovery}}
      - |
        if [ "{{inputs.error_recovery}}" = "true" ]; then
          echo "üîß MODO RECUPERACI√ìN DE ERROR ACTIVADO"
          # Verificaciones adicionales para recuperaci√≥n
          echo "Verificando conectividad..."
          ping -c 1 {{vars.org_ip}} || echo "‚ö†Ô∏è Conectividad limitada"
        fi

  - id: execute_dumps
    type: io.kestra.plugin.scripts.shell.Commands
    description: "Ejecutar dumps seg√∫n par√°metros"
    commands:
      - echo "üöÄ Ejecutando dumps..."
      - |
        case "{{inputs.dump_type}}" in
          "loki")
            echo "üìä Ejecutando Loki dump..."
            curl -G "http://localhost:3100/loki/api/v1/export" \
              -d 'query={job="monitoring"}' \
              -d 'start='$(date -d '1 hour ago' +%s)000000000 \
              -d 'end='$(date +%s)000000000 \
              -o "loki_dump_$(date +%Y%m%d_%H%M%S).json"
            echo "‚úÖ Loki dump completado"
            ;;
          "prometheus")
            echo "üìà Ejecutando Prometheus dump..."
            curl "http://localhost:9090/api/v1/query" \
              -d 'query=up{job="monitoring"}' \
              -d 'time='$(date +%s) \
              -o "prometheus_dump_$(date +%Y%m%d_%H%M%S).json"
            echo "‚úÖ Prometheus dump completado"
            ;;
          "both")
            echo "üìäüìà Ejecutando ambos dumps..."
            # Loki dump
            curl -G "http://localhost:3100/loki/api/v1/export" \
              -d 'query={job="monitoring"}' \
              -d 'start='$(date -d '1 hour ago' +%s)000000000 \
              -d 'end='$(date +%s)000000000 \
              -o "loki_dump_$(date +%Y%m%d_%H%M%S).json"
            
            # Prometheus dump
            curl "http://localhost:9090/api/v1/query" \
              -d 'query=up{job="monitoring"}' \
              -d 'time='$(date +%s) \
              -o "prometheus_dump_$(date +%Y%m%d_%H%M%S).json"
            
            echo "‚úÖ Ambos dumps completados"
            ;;
          *)
            echo "‚ùå Tipo de dump no v√°lido: {{inputs.dump_type}}"
            exit 1
            ;;
        esac

triggers:
  - id: manual_dump_trigger
    type: io.kestra.core.models.triggers.types.Manual
    inputs:
      - id: dump_type
        type: SELECT
        values: ["loki", "prometheus", "both"]
      - id: error_recovery
        type: BOOLEAN
        defaults: false

# =============================================================================
# FLOW DE LIMPIEZA/KILL
# =============================================================================
---
id: cleanup_kill_flow
namespace: dev.monitoring
description: "Limpiar recursos y hacer kill del sistema"

inputs:
  - id: confirm_cleanup
    type: BOOLEAN
    defaults: false
    description: "‚ùì ¬øConfirmas que quieres ejecutar la limpieza/kill?"
    
  - id: force_kill
    type: BOOLEAN
    defaults: false
    description: "¬øForzar limpieza aunque haya errores?"
    
  - id: target_container
    type: STRING
    description: "Nombre del contenedor a limpiar (opcional)"

tasks:
  - id: validate_cleanup_confirmation
    type: io.kestra.plugin.scripts.shell.Commands
    description: "Validar confirmaci√≥n para limpieza"
    commands:
      - |
        if [ "{{inputs.confirm_cleanup}}" != "true" ]; then
          echo "‚ùå LIMPIEZA CANCELADA - Confirmaci√≥n no recibida"
          echo "‚ö†Ô∏è Para ejecutar cleanup, marca 'confirm_cleanup' como true"
          echo "‚ö†Ô∏è ADVERTENCIA: Esto eliminar√° todos los contenedores de monitoreo"
          exit 1
        fi
        
        echo "‚úÖ Confirmaci√≥n de limpieza recibida"
        echo "üßπ Procediendo con cleanup..."
        echo "Forzar kill: {{inputs.force_kill}}"
        echo "Contenedor objetivo: {{inputs.target_container}}"

  - id: cleanup_resources
    type: io.kestra.plugin.scripts.shell.Commands
    description: "Limpiar todos los recursos"
    commands:
      - echo "üßπ Iniciando limpieza de recursos..."
      - |
        # Determinar contenedor objetivo
        if [ -n "{{inputs.target_container}}" ]; then
          CONTAINER_NAME="{{inputs.target_container}}"
        else
          CONTAINER_NAME="monitoring_container_*"
        fi
        
        echo "üéØ Limpiando contenedor(es): $CONTAINER_NAME"
        
        # Detener contenedores
        for container in $(docker ps -a --format "{{.Names}}" | grep -E "^monitoring_container_"); do
          echo "üõë Deteniendo contenedor: $container"
          docker stop "$container" || echo "‚ö†Ô∏è No se pudo detener $container"
          
          echo "üóëÔ∏è Eliminando contenedor: $container"
          docker rm "$container" || echo "‚ö†Ô∏è No se pudo eliminar $container"
        done
        
        # Limpiar archivos temporales
        echo "üßπ Limpiando archivos temporales..."
        rm -f /tmp/flow_status* || true
        rm -f /tmp/user_signal* || true
        
        # Limpiar dumps antiguos (opcional)
        echo "üßπ Limpiando dumps antiguos..."
        find . -name "*_dump_*.json" -mtime +7 -delete || true
        
        echo "‚úÖ Limpieza completada"

triggers:
  - id: manual_kill_trigger
    type: io.kestra.core.models.triggers.types.Manual
    inputs:
      - id: force_kill
        type: BOOLEAN
        defaults: false

# =============================================================================
# INSTRUCCIONES DE USO
# =============================================================================

# üìã C√ìMO USAR EL SISTEMA:

# 1. EJECUCI√ìN NORMAL:
#    - Ejecutar "monitoring_flow_with_error_handling"
#    - El sistema inicia monitoreo
#    - Si hay error ‚Üí se pausa autom√°ticamente
#    - Si todo OK ‚Üí pausa normal para intervenci√≥n humana
#    - BOT√ìN KILL SIEMPRE VISIBLE en la UI

# 2. CUANDO HAY ERROR:
#    - El flow se pausa autom√°ticamente
#    - Revisa los logs para entender el error
#    - Decide si:
#      a) Continuar: Ejecutar "dump_execution_flow" con error_recovery=true
#      b) Kill: Usar bot√≥n Kill o ejecutar "cleanup_kill_flow"

# 3. PAUSA NORMAL:
#    - Ejecutar "dump_execution_flow" con los par√°metros deseados
#    - O usar bot√≥n Kill si quieres detener todo

# 4. LIMPIEZA:
#    - Ejecutar "cleanup_kill_flow" para limpiar recursos
#    - O simplemente usar bot√≥n Kill en cualquier momento

# üéØ VENTAJAS:
# ‚úÖ Bot√≥n Kill siempre visible
# ‚úÖ Pausa autom√°tica en errores
# ‚úÖ Logs detallados para debugging
# ‚úÖ Recuperaci√≥n granular de errores
# ‚úÖ Limpieza completa de recursos
# ‚úÖ UI integrada con Select para par√°metros
# ‚úÖ Acceso remoto total